{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"page2/","title":"Graph","text":""},{"location":"page2/#docstrings","title":"Docstrings","text":"<pre><code>    \"\"\"Exception raised for invalid service names.\"\"\"\n    pass\n\n\nclass ServiceNotFoundException(Exception):\n    \"\"\"Exception raised when a service is not found.\"\"\"\n</code></pre> <pre><code>    \"\"\"Represents a node in the execution graph, encapsulating a service.\"\"\"\n\n    def __init__(self, service_name, service_path, instructions):\n        \"\"\"\n</code></pre> <pre><code>        \"\"\"\n        self.service_name = service_name  # Store the service name for dynamic loading\n        self.name = service_name\n        self.instructions = instructions # instructions for this node\n        self.path = service_path # the service path that is invoked importlib\n        self.dependencies = []  # List of node names this node depends on\n        self.consumers = []  # List of Node instances that depend on this node\n\n    def add_dependency(self, dependency_node):\n        \"\"\"\n</code></pre> <pre><code>        \"\"\"\n        self.dependencies.append(dependency_node)\n        dependency_node.consumers.append(self)\n\n\nclass Graph:\n    \"\"\"Manages the execution graph of services based on their dependencies.\"\"\"\n</code></pre> <pre><code>        \"\"\"\n        Initialize the class instance.\n\n        :param available_services: A list of available services.\n        :param db: The database instance.\n        :param llm: The large language model instance.\n        :param vdb: The vector database instance.\n        \"\"\"\n</code></pre> <pre><code>        \"\"\"\n        Adds a node to the graph.\n\n        Args:\n            node (Node): The node to add to the graph.\n        \"\"\"\n</code></pre> <pre><code>        \"\"\"Executes the graph, respecting node dependencies, and allows for parallel execution.\n        Key Assumptions:\n        Parallel Execution: Nodes without dependencies are submitted for execution immediately. As each node completes, its output is stored, and the executor checks if dependent (consumer) nodes are ready to be executed (i.e., all their dependencies have completed). This allows for parallel execution where possible.\n\n        Dynamic Parameter Passing: When executing a service, parameters (user_prompt and service_input) are dynamically passed based on the service method's signature. This flexible approach caters to different service requirements.\n\n        Handling Multiple Dependencies: When a node has multiple dependencies, the outputs of all dependencies are collected into a list and passed as service_input. This approach assumes that services designed to accept inputs from multiple nodes can handle a list of inputs.\n\n        \"\"\"\n</code></pre> <pre><code>        \"\"\"Instantiates and runs a node's service, passing necessary parameters.\"\"\"\n        # Assuming dynamic loading if necessary or direct instantiation\n\n        # Get the signature of the __init__ method\n        init_signature = inspect.signature(service_class.__init__)\n\n        # Get the parameters of the __init__ method\n        init_params = init_signature.parameters\n\n        # Prepare parameters\n        params = {}\n\n        for name, param in init_params.items():\n            #print(f\"Parameter: {name} - Default: {param.default}\")\n            if name == 'db':\n                params['db'] = self.db\n\n            elif name == 'llm':\n                params['llm'] = self.llm\n\n            elif name == 'vdb':\n                params['vdb'] = self.vdb\n\n        # here we pass the prompt\n        service_instance = service_class(**params)\n\n        # Prepare parameters\n        params = {}\n        sig = inspect.signature(service_instance.run)\n        if 'user_prompt' in sig.parameters:\n            params['user_prompt'] = user_prompt\n        if 'service_input' in sig.parameters:\n            # Aggregate inputs from dependencies\n            inputs = [node_outputs[dep.name] for dep in node.dependencies if dep.name in node_outputs]\n            params['service_input'] = inputs if inputs else None\n\n        response = service_instance.run(**params)\n        logging.info(f\"Response from service {node.service_name}: {response}\")\n        # if we have a response with some data from a services, it will be structured as BaseResponse object\n\n        return response\n\n    def get_dependency_tree(self):\n        \"\"\"Prints the dependency tree of the graph.\"\"\"\n</code></pre>"},{"location":"page2/#code","title":"Code","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nimport logging\nimport inspect\nimport json\n\nclass InvalidServiceNameException(Exception):\n    pass\n\n\nclass Node:\n        Initializes a node with the service it represents (by name), its own name, and a shared context.\n\n        Args:\n            service_name (str): The fully qualified name of the service class this node represents,\n                                including the module and class name (e.g., 'your_module.ServiceA').\n            name (str): The name of the node, typically matching the service it represents.\n            context (Context): A context object containing shared resources like the database engine.\n        Adds a dependency to this node. This node's execution will wait until the dependency node has been executed.\n\n        Args:\n            dependency_node (Node): Another node that this node depends on.\n\n    def __init__(self, available_services, db, llm, vdb):\n        self.available_services = available_services\n        self.nodes = {}\n        self.db = db\n        self.llm = llm\n        self.vdb = vdb\n\n    def add_node(self, service, details):\n        if service not in self.available_services:\n            logging.warning(f\"Trying to add non existent service: {service}\")\n            return\n        node = Node(service, self.available_services[service]['path'], details['Instructions'])\n\n        self.nodes[node.name] = node\n\n    def build_service_dependency(self, selected_services):\n        # Then, set up dependencies based on the JSON response\n        for service, details in selected_services.items():\n            if len(details['DependsOn']) &gt; 0:\n                try:\n                    dependency_node = self.nodes.get(service)\n                except Exception as e:\n                    logging.warning(f\"Dep node not found: {dependency_node}. {e}\")\n\n                for master_name in details['DependsOn']:\n                    try:\n                        master_node = self.nodes.get(master_name)  # Retrieve the node from temporary storage\n                    except Exception as e:\n                        logging.warning(f\"Dep node not found: {dependency_node}. {e}\")\n\n                    if master_node and dependency_node:\n                        dependency_node.add_dependency(master_node)\n\n    def run(self, services):\n        # Initialize execution queue with nodes having no dependencies\n\n        with ThreadPoolExecutor() as executor:\n            futures_to_nodes = {}\n            node_outputs = {}\n            executed_nodes = set()  # Track executed nodes\n\n            # Identify initially ready nodes (no dependencies)\n            ready_nodes = [node for node in self.nodes.values() if not node.dependencies]\n\n            while ready_nodes or futures_to_nodes:\n                # Execute all ready nodes\n                for node in ready_nodes:\n                    if node.name not in executed_nodes:  # Check if node has been executed\n                        logging.info(f\"==== RUNNING SERVICE: {node.name}\\n Prompt: {node.instructions} \\n Inputs: {str(node_outputs)}\")  # Print the current node being executed\n\n                        future = executor.submit(self.run_service, node, services[node.name]['class_inst'], node.instructions, node_outputs)\n                        futures_to_nodes[future] = node\n                        executed_nodes.add(node.name)  # Mark node as executed\n                ready_nodes.clear()\n\n                # Wait for at least one node to complete\n                for future in as_completed(futures_to_nodes):\n                    completed_node = futures_to_nodes.pop(future)  # Pop to prevent re-execution\n                    result = future.result()\n\n                    # Store the result for dependent nodes as a BaseResponse object.\n                    node_outputs[completed_node.name] = result if result.content is not None else None\n\n                    # Check and schedule dependent nodes\n                    for consumer in completed_node.consumers:\n                        if all(dep.name in node_outputs and node_outputs[dep.name] is not None for dep in consumer.dependencies):\n                            if consumer.name not in executed_nodes:  # Check if consumer has been executed\n                                ready_nodes.append(consumer)\n\n        return node_outputs  # Return the aggregated results\n\n    def run_service(self, node, service_class, user_prompt=None, node_outputs=None):\n        def create_tree(node, level=0):\n            tree = {'name': node.name, 'level': level, 'consumers': []}\n            for consumer in node.consumers:\n                tree['consumers'].append(create_tree(consumer, level + 1))\n            return tree\n\n        # Start from nodes without dependencies and print the tree\n        root_nodes = [node for node in self.nodes.values() if not node.dependencies]\n        trees = [create_tree(node) for node in root_nodes]\n        logging.info(\"Node Dependency Trees:\")\n        for tree in trees:\n            logging.info(json.dumps(tree, indent=2))\n</code></pre>"}]}